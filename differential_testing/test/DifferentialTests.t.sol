pragma solidity 0.8.13;

import "../../src/Merkle.sol";
import "forge-std/Test.sol";
import "openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol";
import "openzeppelin-contracts/contracts/utils/Strings.sol";
import "forge-std/console.sol";

contract DifferentialTests is Test {

    // Contracts (to be migrated to libraries)
    Merkle m;
    bytes32[100] data;

    function setUp() public {
        m = new Merkle();
    }
    
    function testMerkleRootMatchesJSImplementation() public {
        // Run the reference implementation in javascript
        string[] memory runJsInputs = new string[](6);
        runJsInputs[0] = 'npm';
        runJsInputs[1] = '--prefix';
        runJsInputs[2] = 'differential_testing/scripts/';
        runJsInputs[3] = '--silent';
        runJsInputs[4] = 'run';
        runJsInputs[5] = 'generate-root';
        bytes memory jsResult = vm.ffi(runJsInputs);
        bytes32 jsGeneratedRoot = abi.decode(jsResult, (bytes32));

        // Read in the file generated by the reference implementation 
        string[] memory loadJsDataInputs = new string[](2);
        loadJsDataInputs[0] = "cat";
        loadJsDataInputs[1] = "differential_testing/data/input";
        bytes memory loadResult =  vm.ffi(loadJsDataInputs);
        data  = abi.decode(loadResult, (bytes32[100]));

        // Calculate root using Murky
        bytes32 murkyGeneratedRoot = m.getRoot(_getData());
        assertEq(murkyGeneratedRoot, jsGeneratedRoot);
    }

    /*
    function testMerkleRootMatchesJSImplementationFuzzed() public {
        // this will be fuzzed, just static for testing
        bytes memory tst = abi.encodePacked(bytes32(uint256(0xdead)));
        emit log_bytes(tst);
        bytesToHexString(tst);

        /*
        bytes32[4] memory tst = [
                    bytes32(uint256(0xdead)),
                    bytes32(uint256(0xface)),
                    bytes32(uint256(0xbabe)),
                    bytes32(uint256(0x1337))];

        string memory packed = "";
        for (uint i = 0; i < tst.length; ++i) {
            packed = string.concat(packed, Strings.toHexString(uint256(tst[i]), 32));
        }

        emit log_string(packed);

        string memory str = toHex(tst[0]);
        emit log_string(str);
        string memory str2 = Strings.toHexString(uint256(bytes32(tst[0])), 32);
        emit log_string(str2);
        bytes memory encoded = abi.encodePacked(tst);
        // this logs the data as the typescript consumable string
        emit log_bytes(encoded);
        string[] memory runJsInputs = new string[](7);
        runJsInputs[0] = 'npm';
        runJsInputs[1] = '--prefix';
        runJsInputs[2] = 'differential_testing/scripts/';
        runJsInputs[3] = '--silent';
        runJsInputs[4] = 'run';
        runJsInputs[5] = 'generate-root-stdin';
        // can't convert bytes to string though
        //runJsInputs[6] = string(encoded); 
        //bytes memory jsResult = vm.ffi(runJsInputs);
        //bytes32 jsGeneratedRoot = abi.decode(jsResult, (bytes32));
        //emit log_bytes32(jsGeneratedRoot);
        /*
        // Read in the file generated by the reference implementation 
        string[] memory loadJsDataInputs = new string[](2);
        loadJsDataInputs[0] = "cat";
        loadJsDataInputs[1] = "differential_testing/data/input";
        bytes memory loadResult =  vm.ffi(loadJsDataInputs);
        data  = abi.decode(loadResult, (bytes32[100]));

        // Calculate root using Murky
        bytes32 murkyGeneratedRoot = m.getRoot(_getData());
        assertEq(murkyGeneratedRoot, jsGeneratedRoot);
        */
    }

    function testCompatabilityOpenZeppelinProver(bytes32[] memory _data, uint256 node) public {
        vm.assume(_data.length > 1);
        vm.assume(node < _data.length);
        bytes32 root = m.getRoot(_data);
        bytes32[] memory proof = m.getProof(_data, node);
        bytes32 valueToProve = _data[node];
        bool murkyVerified = m.verifyProof(root, proof, valueToProve);
        bool ozVerified = MerkleProof.verify(proof, root, valueToProve);
        assertTrue(murkyVerified == ozVerified);
    }

    function _getData() public view returns (bytes32[] memory) {
        bytes32[] memory _data = new bytes32[](data.length);
        uint length = data.length;
        for (uint i = 0; i < length; ++i) {
            _data[i] = data[i];
        }
        return _data;
    }

    function bytesToHexString(bytes memory input) public returns (string memory) {
        bytes16 symbols = "0123456789abcdef";
        bytes memory hex_string = new bytes(2 * input.length + 2);
        uint pos = 0;
        for (uint i = 0; i < input.length; ++i) {
            console.logBytes32(input[i]);
            hex_string[pos] = symbols[(uint256(bytes32(input[i])) >> 252)];
            hex_string[pos+1] = symbols[(uint256(bytes32(input[i])) >> 248 & 0xf)];
            console.log(string(hex_string));
            pos +=2;
        }
        return "";
    }
}